{"config":{"output_file":null,"full_docs":false,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0","program":"/Users/masatoshi/.rustup/toolchains/nightly-x86_64-apple-darwin/bin/rls","arguments":["--crate-name","superslice","/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata","-C","debuginfo=2","-C","metadata=f7798e8fc2f6a10e","-C","extra-filename=-f7798e8fc2f6a10e","--out-dir","/Users/masatoshi/Documents/atcoder/dp/target/rls/debug/deps","-L","dependency=/Users/masatoshi/Documents/atcoder/dp/target/rls/debug/deps","--cap-lints","allow","--error-format=json","--sysroot","/Users/masatoshi/.rustup/toolchains/nightly-x86_64-apple-darwin"],"output":"/Users/masatoshi/Documents/atcoder/dp/target/rls/debug/deps/libsuperslice-f7798e8fc2f6a10e.rmeta"},"prelude":{"crate_id":{"name":"superslice","disambiguator":[6189747346678578218,424683426158133674]},"crate_root":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src","external_crates":[{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":1,"id":{"name":"std","disambiguator":[10613055454315904869,2811732849881954636]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":2,"id":{"name":"core","disambiguator":[391827052702496084,5129134181362070381]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[4281604570573728273,9331809846264551407]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[16197749903097291620,17943825029647261869]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":5,"id":{"name":"alloc","disambiguator":[10845582213263607778,379097389567409069]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":6,"id":{"name":"libc","disambiguator":[844407882680543608,18229321760257986125]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":7,"id":{"name":"unwind","disambiguator":[3570085749873741306,6541745440181859048]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[2578273522758280898,17913597462815022013]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":9,"id":{"name":"backtrace","disambiguator":[735647405049555546,6998326938186734761]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":10,"id":{"name":"rustc_demangle","disambiguator":[10449409484459928313,13344031615333270257]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":11,"id":{"name":"backtrace_sys","disambiguator":[886225832632004317,14255593997978316403]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":12,"id":{"name":"hashbrown","disambiguator":[2255118238040761479,18238811431415079153]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":13,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[16030725988839514509,13221492198480567872]}},{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","num":14,"id":{"name":"panic_unwind","disambiguator":[4378005683902666456,14285554179360740773]}}],"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":595,"byte_end":19293,"line_start":15,"line_end":615,"column_start":1,"column_end":2}},"imports":[],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":595,"byte_end":19293,"line_start":15,"line_end":615,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":7},{"krate":0,"index":37},{"krate":0,"index":74},{"krate":0,"index":76}],"decl_id":null,"docs":" This crate provides extensions for [`slice`]s.\n \n # Examples\n \n ```\n use superslice::*;\n \n let b = [1, 3];\n \n assert_eq!(b.lower_bound(&1), 0);\n \n assert_eq!(b.upper_bound(&1), 1);\n \n assert_eq!(b.equal_range(&3), 1..2);\n ```\n \n [`slice`]: https://doc.rust-lang.org/stable/std/primitive.slice.html\n","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":7},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":1143,"byte_end":1146,"line_start":37,"line_end":37,"column_start":11,"column_end":14},"name":"Ext","qualname":"::Ext","value":"Ext","parent":null,"children":[{"krate":0,"index":8},{"krate":0,"index":9},{"krate":0,"index":10},{"krate":0,"index":13},{"krate":0,"index":17},{"krate":0,"index":18},{"krate":0,"index":21},{"krate":0,"index":25},{"krate":0,"index":26},{"krate":0,"index":29},{"krate":0,"index":33},{"krate":0,"index":34},{"krate":0,"index":35},{"krate":0,"index":36}],"decl_id":null,"docs":" Extends [`slice`] with fast operations on ordered slices.\n \n [`slice`]: https://doc.rust-lang.org/stable/std/primitive.slice.html\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":8},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":1158,"byte_end":1162,"line_start":38,"line_end":38,"column_start":10,"column_end":14},"name":"Item","qualname":"::Ext::Item","value":"type Item;","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":1842,"byte_end":1853,"line_start":59,"line_end":59,"column_start":8,"column_end":19},"name":"lower_bound","qualname":"::Ext::lower_bound","value":"fn (&self, x: &Self::Item) -> usize","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Returns the index `i` pointing to the first element in the ordered slice\n that is _not less_ than `x`.\n \n The slice MUST be ordered by the order defined by its elements.\n \n # Example:\n \n ```\n # use superslice::*;\n let a = [10, 11, 13, 13, 15];\n assert_eq!(a.lower_bound(&9), 0);\n assert_eq!(a.lower_bound(&10), 0);\n assert_eq!(a.lower_bound(&11), 1);\n assert_eq!(a.lower_bound(&12), 2);\n assert_eq!(a.lower_bound(&13), 2);\n assert_eq!(a.lower_bound(&14), 4);\n assert_eq!(a.lower_bound(&15), 4);\n assert_eq!(a.lower_bound(&16), 5);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":10},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":2476,"byte_end":2490,"line_start":77,"line_end":77,"column_start":8,"column_end":22},"name":"lower_bound_by","qualname":"::Ext::lower_bound_by","value":"fn <'a, F> (&'a self, f: F) -> usize","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Returns the index `i` pointing to the first element in the ordered slice\n for which `f(self[i]) != Less`.\n \n The slice MUST be ordered by the order defined by the comparator\n function. The comparator function should take an element and return\n `Ordering` that is consistent with the ordering of the slice.\n \n # Example:\n \n ```\n # use superslice::*;\n let b = [1, 2, 3, 6, 9, 9];\n assert_eq!(b.lower_bound(&3), b.lower_bound_by(|x| x.cmp(&3)));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":13},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":3008,"byte_end":3026,"line_start":94,"line_end":94,"column_start":8,"column_end":26},"name":"lower_bound_by_key","qualname":"::Ext::lower_bound_by_key","value":"fn <'a, K, F> (&'a self, k: &K, f: F) -> usize","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Returns the index `i` pointing to the first element in the ordered slice\n for which `f(self[i]) >= k`.\n \n The slice MUST be ordered by the order defined by the keys of its\n elements.\n \n # Example:\n \n ```\n # use superslice::*;\n let b = [1, 2, 3, 6, 9, 9];\n assert_eq!(b.lower_bound(&3), b.lower_bound_by_key(&6, |x| x * 2));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":17},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":3811,"byte_end":3822,"line_start":118,"line_end":118,"column_start":8,"column_end":19},"name":"upper_bound","qualname":"::Ext::upper_bound","value":"fn (&self, x: &Self::Item) -> usize","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Returns the index `i` pointing to the first element in the ordered slice\n that is _greater_ than `x`.\n \n The slice MUST be ordered by the order defined by its elements.\n \n # Example:\n \n ```\n # use superslice::*;\n let a = [10, 11, 13, 13, 15];\n assert_eq!(a.upper_bound(&9), 0);\n assert_eq!(a.upper_bound(&10), 1);\n assert_eq!(a.upper_bound(&11), 2);\n assert_eq!(a.upper_bound(&12), 2);\n assert_eq!(a.upper_bound(&13), 4);\n assert_eq!(a.upper_bound(&14), 4);\n assert_eq!(a.upper_bound(&15), 5);\n assert_eq!(a.upper_bound(&16), 5);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":18},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":4448,"byte_end":4462,"line_start":136,"line_end":136,"column_start":8,"column_end":22},"name":"upper_bound_by","qualname":"::Ext::upper_bound_by","value":"fn <'a, F> (&'a self, f: F) -> usize","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Returns the index `i` pointing to the first element in the ordered slice\n for which `f(self[i]) == Greater`.\n \n The slice MUST be ordered by the order defined by the comparator\n function. The comparator function should take an element and return\n `Ordering` that is consistent with the ordering of the slice.\n \n # Example:\n \n ```\n # use superslice::*;\n let b = [1, 2, 3, 6, 9, 9];\n assert_eq!(b.upper_bound(&3), b.upper_bound_by(|x| x.cmp(&3)));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":21},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":4967,"byte_end":4985,"line_start":152,"line_end":152,"column_start":8,"column_end":26},"name":"upper_bound_by_key","qualname":"::Ext::upper_bound_by_key","value":"fn <'a, K, F> (&'a self, k: &K, f: F) -> usize","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Returns the index `i` pointing to the first element in the ordered slice\n for which `f(self[i]) > k`.\n \n The slice MUST be ordered by the order defined by the keys of its\n elements.\n \n # Example:\n \n ```\n # use superslice::*;\n let b = [1, 2, 3, 6, 9, 9];\n assert_eq!(b.lower_bound(&3), b.lower_bound_by_key(&6, |x| x * 2));\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":25},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":5610,"byte_end":5621,"line_start":172,"line_end":172,"column_start":8,"column_end":19},"name":"equal_range","qualname":"::Ext::equal_range","value":"fn (&self, x: &Self::Item) -> std::ops::Range<usize>","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Returns the [`Range`] `a..b` such that all elements in `self[a..b]` are\n _equal_ to `x`.\n \n The slice MUST be ordered by the order defined by its elements.\n \n # Example:\n \n ```\n # use superslice::*;\n let b = [10, 11, 13, 13, 15];\n for i in 9..17 {\n     assert_eq!(b.equal_range(&i), (b.lower_bound(&i)..b.upper_bound(&i)));\n }\n ```\n [`Range`]: https://doc.rust-lang.org/stable/std/ops/struct.Range.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":26},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":6372,"byte_end":6386,"line_start":193,"line_end":193,"column_start":8,"column_end":22},"name":"equal_range_by","qualname":"::Ext::equal_range_by","value":"fn <'a, F> (&'a self, f: F) -> std::ops::Range<usize>","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Returns the [`Range`] `a..b` such that for all elements `e` in `self[a..b]` \n `f(e) == Equal`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":29},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":7060,"byte_end":7078,"line_start":214,"line_end":214,"column_start":8,"column_end":26},"name":"equal_range_by_key","qualname":"::Ext::equal_range_by_key","value":"fn <'a, K, F> (&'a self, k: &K, f: F) -> std::ops::Range<usize>","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Returns the [`Range`] `a..b` such that for all elements `e` in `self[a..b]` \n `f(e) == k`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":33},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":8085,"byte_end":8101,"line_start":240,"line_end":240,"column_start":8,"column_end":24},"name":"next_permutation","qualname":"::Ext::next_permutation","value":"fn (&mut self) -> bool","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Transforms the slice into the next permutation from the set of all\n permutations that are lexicographically ordered with respect to the\n natural order of T. Returns true if such permutation exists, otherwise\n transforms the range into the first permutation and returns false.\n \n # Example:\n \n ```\n # use superslice::*;\n let mut b = [2, 1, 3];\n let mut v = Vec::new();\n for _ in 0..6 {\n     let x = b.next_permutation();\n     v.push((x, b.to_vec()));\n }\n assert_eq!(v, &[(true, [2, 3, 1].to_vec()),\n                 (true, [3, 1, 2].to_vec()),\n                 (true, [3, 2, 1].to_vec()),\n                 (false, [1, 2, 3].to_vec()),\n                 (true, [1, 3, 2].to_vec()),\n                 (true, [2, 1, 3].to_vec())]);\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":34},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":9041,"byte_end":9057,"line_start":265,"line_end":265,"column_start":8,"column_end":24},"name":"prev_permutation","qualname":"::Ext::prev_permutation","value":"fn (&mut self) -> bool","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Transforms the slice into the previous permutation from the set of all\n permutations that are lexicographically ordered with respect to the\n natural order of T. Returns true if such permutation exists, otherwise\n transforms the range into the last permutation and returns false.\n \n # Example:\n \n ```\n # use superslice::*;\n let mut b = [2, 1, 3];\n let mut v = Vec::new();\n for _ in 0..6 {\n     let x = b.prev_permutation();\n     v.push((x, b.to_vec()));\n }\n assert_eq!(v, &[(true, [1, 3, 2].to_vec()),\n                 (true, [1, 2, 3].to_vec()),\n                 (false, [3, 2, 1].to_vec()),\n                 (true, [3, 1, 2].to_vec()),\n                 (true, [2, 3, 1].to_vec()),\n                 (true, [2, 1, 3].to_vec())]);\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":35},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":9931,"byte_end":9948,"line_start":292,"line_end":292,"column_start":8,"column_end":25},"name":"apply_permutation","qualname":"::Ext::apply_permutation","value":"fn (&mut self, permutation: &mut [isize]) -> ()","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Applies `permutation` to the slice. For each element at index `i` the\n following holds:\n \n   new_self[i] == old_self[permutation[i]]","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":36},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":10830,"byte_end":10855,"line_start":317,"line_end":317,"column_start":8,"column_end":33},"name":"apply_inverse_permutation","qualname":"::Ext::apply_inverse_permutation","value":"fn (&mut self, permutation: &mut [isize]) -> ()","parent":{"krate":0,"index":7},"children":[],"decl_id":null,"docs":" Applies the inverse of `permutation` to the slice. For each element at\n index `i` the following holds:\n \n   new_self[permutation[i]] == old_self[i]","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":74},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":16831,"byte_end":16835,"line_start":529,"line_end":529,"column_start":11,"column_end":15},"name":"Ext2","qualname":"::Ext2","value":"Ext2","parent":null,"children":[{"krate":0,"index":75}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":75},"span":{"file_name":"/Users/masatoshi/.cargo/registry/src/github.com-1ecc6299db9ec823/superslice-1.0.0/src/lib.rs","byte_start":17197,"byte_end":17215,"line_start":543,"line_end":543,"column_start":8,"column_end":26},"name":"invert_permutation","qualname":"::Ext2::invert_permutation","value":"fn (&mut self) -> ()","parent":{"krate":0,"index":74},"children":[],"decl_id":null,"docs":" Transforms the slice in the inverse permutation.\n \n # Panics\n \n This function panics if any value in `self` is not in `0..self.len()`.\n \n # Example:\n \n ```\n # use superslice::*;\n let mut p = [1, 3, 2, 0];\n p.invert_permutation();\n assert_eq!(p, [3, 0, 2, 1]);\n","sig":null,"attributes":[]}],"impls":[],"refs":[],"macro_refs":[],"relations":[]}